# 7장. 영구적 저장 상태의 실용성
##### 데이터 처리 파이프라인에서 영구적인 저장 상태가 필요한 이유?
내용을 나중에 다시 확인할 수 있도록 붙잡아두자! 6장에서 언급한 테이블이 영구적인 저장 상태(persistent state)이다. 다만 테이블이 손실이 없는 매체에 저장돼야 한다는 요구 사항이 따른다.

##### 7장의 목표
- 파이프라인에서 영구적인 저장 상태의 필요성을 깨닫는다.
- 파이프라인에서 쉽게 만날 수 있는 두 가지 암시적 저장 상태를 살펴본다.
- 암시적 저장 상태가 적합하지 않은 실제 사용 사례를 살펴보고, 일반화된 명시적인 상태 관리의 중요한 특징들을 살펴본다.
- 아파치 빔에서 볼 수 있는 것과 같은 저장 상태 API를 구체적으로 살펴본다.

## 동기부여
테이블을 저장하는 이유는 그 안에 포함된 일시적인 데이터를 붙잡아두는 것이다. 이것이 왜 필요할까?

### 불가피한 실패
무한(unbounded) 입력 데이터를 처리하는 경우를 보자. 무한 데이터를 처리하는 파이프라인은 영원히 실행되는 것을 의도하고 있지만, 불가피하게 중단되는 경우가 생긴다. 이때 중단 지점부터 작업을 다시 시작할 수 있도록 하기 위해 파이프라인은 중단 전 지점까지의 기록이 필요하다. 이 부분이 영구적인 저장 상태가 필요한 지점이다.

이 문제는 무한 데이터와만 관련된 것일까? 배치 파이프라인도 영구적인 저장 상태가 필요할까? 유한 데이터는 본질적으로 크기가 한정돼 있다. 배치 시스템은 그러한 경우에 맞게 실패하는 상황이 발생하면 데이터를 전체적으로 재처리할 수 있다고 가정한다. 즉, 동일한 입력을 다시 읽어 처리한다. 이를 입력 재처리(input reprocessing)라고 한다.

반면 무한 데이터는 그 크기가 무한하다고 가정해야 한다. 따라서 재처리에 데이터를 일부분만 사용할 수 있다고 가정한다. '최소한 한 번' 보장 또는 '정확히 한 번' 보장을 제공하려면 더 이상 재처리에 쓸 수 없는 모든 데이터는 영구적으로 유지되는 체크포인트 대상으로 고려해야 한다.

결국 영구적인 저장 상태를 배치 또는 스트리밍이라는 특성과 무관하다. 다만 무제한 데이터를 처리할 때 그 중요성이 크므로 일반적으로 스트리밍 시스템이 영구적인 저장 상태를 더욱 정교하게 지원한다.

### 정확성 및 효율성
데이터 처리 중 실패가 발생하고 데이터 재처리하는 상황에서 영구적인 저장 상태는 다음 두 가지를 제공해준다.

- 일시적인 입력에 대한 정확성을 제공하는 근간이 된다. 
  - 파이프인에서 이전에 받은 데이터를 버린 후에도 처리를 계속할 수 있도록 필요한 중간 결과를 유지하게 해준다.
- 실패 복구 과정에서 중복 작업과 저장해야 하는 데이터를 최소화하는 방법을 제공한다.
  - 입력이 일시적인지 여부에 관계없이 파이프라인을 재실행하면 체크포인트되지 않은 부분은 다시 계산을 수행해야 한다.
  - 파이프라인 내 진행 상황을 체크포인트함으로써, 오류 발생 시 반복해야 하는 작업량을 크게 줄일 수 있다.
  - 유지해야 하는 데이터 양을 최소화. 파이프라인 내 체크포인트 시점까지의 모든 입력을 저장하는 것보다 훨씬 적은 공간을 차지하는 중간 계산 값을 저장하는 것이 실용적이다.
  - 더 이상 필요 없는 영구적인 저장 상태는 가비지 컬렉션. 영원히 들어오는 입력임에도 영구적인 저장 상태에 유지되는 데이터 양을 시간과 무관하게 일정한 수준ㅇ으로 유지할 수 있다. 이를 통해 파이프라인이 강력한 일관성 보장을 제공하면서 파이프라인에 주어진 원시 입력을 모두 기억할 필요 없이 실제로 영구적으로 동작하도록 만들 수 있다.

## 암시적 상태
##### 항상 저장하는 것 vs 아무것도 저장하지 않는 것
영구적인 저장 상태에 항상 저장하는 것(일관성이 좋으나 효율성이 좋지 않음)과 아무것도 저장하지 않는 것(일관성은 좋지 않고 효율성이 좋음) 사이에서 적절한 균형을 찾아, 일관성을 망치지 않으면서 효율성으로 인한 구현 복잡도를 조절하는 방법을 살펴보자. 데이터를 그룹핑하는 과정에서 생성된 중간 결과를 테이블 내에 유지하는 방법을 중심으로 이야기하고자 한다.

### 원시 그룹핑
모든 데이터를 항상 저장하는 방식으로 파이프라인 내 그룹핑을 가장 간단한 형태인 원시 그룹핑(raw grouping)으로 구현해보자. 이 경우 그룹핑은 리스트에 데이터를 계속 추가하는 작업으로, 새 데이터가 그룹핑 작업에 도착할 때 마다 해당 그룹의 리스트에 추가된다.
> 빔에서는 GroupByKey 변환을 PCollection에 적용하여 얻을 수 있다.

##### 예 7-1. 조기/정시/지연 API를 통한 조기, 정시 및 지연 점화
```
PCollection<String> raw = IO.read(...);
PCollection<KV<String, Integer>> input = raw.apply(new ParseFn());
PCollection<KV<String, Iterable<Integer>>> groupedScores = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))  // 2분 단위 고정 윈도우 적용
                .triggering(AfterWatermark()  // 워터마크 적용
                    .withEarlyFirings(AlignedDelay(ONE_MINUTE))  // 1분 단위 정렬 지연 트리거 적용
                    .withLateFirings(AfterCount(1))) // 매 입력마다 동작하는 트리거 적용
                  ))
  .apply(GroupByKey.<String, Integer>create());

PCollection<KV<String, Integer>> totals = groupedScores
  .apply(MapElements.via(KV<String, Iterable<Integer>> kv) -> 
      StreamSupport.intStream(
      kv.getValue.spliterator(), false).sum())));
```
1. 파싱된 사용자/점수 키/값 쌍에 GroupByKey 변환 적용
2. Iterable<Integer>를 IntStream<Integer>로 변환하고 sum을 호출

![stsy_0701](https://user-images.githubusercontent.com/19989706/163387011-c8519d60-4161-466d-b785-d3c321967f67.gif)
> 윈도우와 초기/정시/지연 트리거를 사용해 입력의 원시 그룹핑을 통한 합계. 원시 입력은 그룹핑돼 GroupByKey 변환을 통해 테이블에 저장된다. 트리거된 후 MapElements 람다는 단일 패널 내의 원시 입력을 합산해 팀별 점수를 산출한다.

##### 증분 결합 결과와 비교
1. 훨씬 더 많은 데이터를 저장. 윈도우마다 단일 정수 대신 해당 윈도우에 대한 모든 입력을 저장.
2. 여러 트리거가 발생하면 이미 이전 트리거에서 계산했던 입력을 다시 합산. 중복 작업 발생.
3. 그룹핑 작업이 체크포인트하는 지점이라고 해도, 실패가 발생하면 테이블 내 모든 트리거에 대한 합을 다시 계산해야 한다.
더 좋은 방법은 증분 결합으로 실제 합을 점진적으로 계산하고 체크포인트에 사용하는 것.

### 증분 결합
효율성을 위해 구현 복잡성을 높이는 첫 단계는 증분 결합이다. 증분 결합은 결합 법칙과 교환 법칙을 만족하는 결합 연산자상에 생성되는 자동적인 상태의 한 형태로 볼 수 있다.
> 빔에서는 CombineFn 클래스를 통해 구현된다.
  
개념적으로 증분 결합의 기본 개념은 합계, 평균 등 많은 유형의 집계가 다음과 같은 특성을 보인다는 점에서 시작한다.
- 증분 집계(incremental aggregation)는 중간 형태로 입력의 전체 목록보다 간결하게 N개의 입력을 결합한 부분적인 진행 상황을 잡아둔다.
  > 평균의 경우 합계/개수의 쌍, 단순 합은 단일 숫자

- 증분 집계는 다음 두 차원에서 순서와 무관하다.
  - 개별 요소: COMBINE(a, b) == COMBINE(b, a)
  - 요소의 그룹핑: COMBINE(COMBINE(a, b), c) == COMBINE(a, COMBINE(b, c))

이는 요소와 부분 집계를 임의 순서와 임의 하위 그룹으로 자유롭게 결합해도 무방함을 의미한다. 이렇게 하면 다음의 두 가지 방법으로 집계를 최적화할 수 있게 된다.
- 증분화(incrementalization)
  - 개별 입력의 순서가 중요하지 않다. 미리 모든 입력을 버퍼링하여 엄격한 순서로 처리할 필요 없이 데이터가 도착할 때마다 하나씩 간단히 결합할 수 있다.
  - 버퍼링해야 하는 데이터의 양을 크게 감소시킬 있으며, 시간ㅇ에 따른 계산 부하를 균등하게 분산시킬 수 있다.

- 병렬화(parallelization)
  - 입력의 부분적인 그룹이 결합되는 순서가 중요하지 않기 때문에 임의로 그룹 연산을 분배할 수 있다.
  - 그룹 연산을 여러 서버로 분산시킬 수 있다. 각 서버는 부분 집계를 계산하고, 여러 서버에서 생성된 부분 집계를 단일 서버에서 추가로 결합해 최종 집계를 산출할 수 있다.
  - 병렬화 기능을 통해 집계 작업이 윈도우 병합(window merging)과 호환된다.

```
PCollection<String> raw = IO.read(...);
PCollection<KV<String, Integer>> input = raw.apply(new ParseFn());
PCollection<KV<String, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))  // 2분 단위 고정 윈도우 적용
                .triggering(AfterWatermark()  // 워터마크 적용
                    .withEarlyFirings(AlignedDelay(ONE_MINUTE))  // 1분 단위 정렬 지연 트리거 적용
                    .withLateFirings(AfterCount(1))) // 매 입력마다 동작하는 트리거 적용
                  ))
  .apply(Sum.integersPerKey());
```

![stsy_0702](https://user-images.githubusercontent.com/19989706/163387978-d1b6f455-31b8-44a2-96c3-4648b874e47a.gif)
> 

## 일반화된 상태

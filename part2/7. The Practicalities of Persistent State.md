# 7장. 영구적 저장 상태의 실용성
##### 데이터 처리 파이프라인에서 영구적인 저장 상태가 필요한 이유?
나중에 다시 확인할 수 있도록 붙잡아두자! 6장에서 언급한 테이블이 영구적인 저장 상태(persistent state)이다. 다만 테이블이 손실이 없는 매체에 저장돼야 한다는 요구 사항이 따른다.

##### 7장의 목표
- 파이프라인에서 영구적인 저장 상태의 필요성을 깨닫는다.
- 파이프라인에서 쉽게 만날 수 있는 두 가지 암시적 저장 상태를 살펴본다.
- 암시적 저장 상태가 적합하지 않은 실제 사용 사례를 살펴보고, 일반화된 명시적인 상태 관리의 중요한 특징들을 살펴본다.
- 아파치 빔에서 볼 수 있는 것과 같은 저장 상태 API를 구체적으로 살펴본다.

## 동기부여
테이블을 저장하는 이유는 그 안에 포함된 일시적인 데이터를 붙잡아두는 것이다. 이것이 왜 필요할까?

### 불가피한 실패
무한(unbounded) 입력 데이터를 처리하는 경우를 보자. 무한 데이터를 처리하는 파이프라인은 영원히 실행되는 것을 의도하고 있지만, 불가피하게 중단되는 경우가 생긴다. 이때 중단 지점부터 작업을 다시 시작할 수 있도록 하기 위해 파이프라인은 중단 전 지점까지의 기록이 필요하다. 이 부분이 영구적인 저장 상태가 필요한 지점이다.

이 문제는 무한 데이터와만 관련된 것일까? 배치 파이프라인도 영구적인 저장 상태가 필요할까? 유한 데이터는 본질적으로 크기가 한정돼 있다. 배치 시스템은 그러한 경우에 맞게 실패하는 상황이 발생하면 데이터를 전체적으로 재처리할 수 있다고 가정한다. 즉, 동일한 입력을 다시 읽어 처리한다. 이를 입력 재처리(input reprocessing)라고 한다.

반면 무한 데이터는 그 크기가 무한하다고 가정해야 한다. 따라서 재처리에 데이터를 일부분만 사용할 수 있다고 가정한다. '최소한 한 번' 보장 또는 '정확히 한 번' 보장을 제공하려면 더 이상 재처리에 쓸 수 없는 모든 데이터는 영구적으로 유지되는 체크포인트 대상으로 고려해야 한다.

결국 영구적인 저장 상태를 배치 또는 스트리밍이라는 특성과 무관하다. 다만 무제한 데이터를 처리할 때 그 중요성이 크므로 일반적으로 스트리밍 시스템이 영구적인 저장 상태를 더욱 정교하게 지원한다.

### 정확성 및 효율성

## 암시적 상태
## 일반화된 상태

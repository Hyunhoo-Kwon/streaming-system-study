# 6장. 스트림과 테이블
지금까지는 주로 유한과 무한, 즉 데이터의 기수(cardinality)라는 특성에만 집중해왔으며, 덕분에 내부 동작에 대한 큰 고민 없이 무한 데이터셋 도입으로 겪는 어려움을 살펴봤다. 이제 스트림과 테이블, 즉 구성(consititution)이라는 데이터의 특성이 더해지면 어떤 일이 생기는지 살펴보자.

## 스트림/테이블의 기본: 스트림/테이블의 특수상대론
스트림/테이블에 대한 기본적인 아이디어는 데이터베이스 분야에서 나왔다. 테이블은 데이터를 행과 열로 보관하며, 각 열은 명시적이든 아니든 일정 종류의 키로 구분된다. 데이터베이스의 자료 구조는 추가 전용 로그(append-only log)이며, 트랜잭션이 테이블에 적용될 때 이 트랜잭션은 로그에 기록된다. 그리고 이 로그의 내용이 테이블에 적용되면서 테이블상에 갱신 내용이 구체화된다.

##### 스트림에서 테이블을 만드는 방법?
스트림/테이블에 대응시켜보자면 이 로그는 스트림에 해당한다. 테이블은 스트림에서 보이는 트랜잭션 로그를 적용한 결과라 볼 수 있다.
- 스트림 -> 테이블: 시간에 따른 업데이트 내용을 담은 스트림을 모아 테이블을 생성한다.

##### 테이블에서 스트림은 어떻게 만들어낼 수 있을까?
스트림은 테이블의 변화 로그(changelog)에 해당한다.
> e.g. 테이블에서 스트림으로의 변환을 설명할 때 쓰이는 예로 구체화 뷰(materialized view)가 있다. 테이블에 쿼리를 적용해 구체화 뷰를 생성하고, 이 구체화 뷰는 데이터베이스 내에서 또 다른 물리 테이블로 생성된다. 구체화 뷰는 해당 쿼리 결과를 캐싱해둔 것으로 볼 수 있으며, 이후 원본 테이블의 내용이 변함에 따라 구체화 뷰 역시 변화한다. 소스 테이블에 변화가 있을 때마다 로그로 남게 되고, 구체화 뷰의 쿼리 문맥 안에서 변화 내용을 구체화 뷰 테이블에 적용한다.
- 테이블 -> 스트림: 시간에 따른 테이블 변화를 관찰해 스트림을 생성한다.

### 스트림/테이블의 일반상대론을 향해서
스트림/테이블 이론을 우리가 알고 있는 빔 모델에 엮기 위해서는 정리해야 할 문제들이 있다.
- 배치 처리(batch processing)는 어떻게 바라봐야 하는가?
- 유한(bounded) 및 무한(unbounded) 데이터셋과 스트림의 관계는 어떻게 되는가?
- 무엇을, 어디서, 언제, 어떻게라는 4가지 문제를 스트림/테이블에 어떻게 적용해야 하는가?

## 배치 처리 대 스트림/테이블

## 스트림/테이블 세상에서의 무엇, 어디서, 언제, 어떻게
### 무엇: 변환
변환(transformation)은 파이프라인이 무엇을 계산하는지 우리에게 알려준다. 
> e.g. 모델을 구축, 합을 계산, 스팸을 필터링

앞서 살펴본 맵리듀스 예에서 6개의 단계 중 4개가 바로 무엇ㅇ에 대한 질문에 답을 준다.
- Map과 Reduce는 모두 변환을 입력 스트림으로 들어오는 키/값에 적용한다. 이를 통해 새로운 변환된 스트림이 생성된다.
- MapWrite와 ReduceWrite는 모두 해당 단계에 배정된 키에 따라 이전 단계에서 나온 출력을 그룹핑한다. 이 변환에서 입력 스트림은 출력 테이블이 된다.

이렇게 살펴보면 스트림/테이블 이론의 관점에서 본질적으로 두 종류의 변환이 있음을 알게 된다.
- 비그룹핑(nongrouping)
  - 이 종류의 연산은 데이터스트림을 받아 새로운 변환된 스트림을 생성한다.
  - e.g. filter, exploder, mutator
- 그룹핑(grouping)
  - 이 연산은 레코드 스트림을 받아 그룹핑해 테이블로 변환한다.
  - e.g. join, aggregator, list/set accumulation, chanegelog application, histogram creation, machine learning model training

이것들이 어떻게 묶일 수 있는지 알아보기 위해 처음 변환에 대해 살펴봤던 예 2-1. 배치: 합계 파이프라인(https://github.daumkakao.com/dmpd/airflow-da-job)을 살펴보자. 
```
// 예 2-1. 배치: 합계 파이프라인
PCollection<String> raw = IO.read(...); // 가공 전의 데이터
PCollection<KV<String, Integer>> input = raw.apply(new ParseFn());  // 팀 이름의 문자열을 키로, 개별 팀 멤버의 점수인 정수를 값으로 파싱
PCollection<KV<String, Integer>> totals = 
  input.apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```
이 파이프라인은 입력 데이터를 읽어 개별 팀 멤버 점수를 파싱하고 팀별로 합을 낸다.

![stsy_0203](https://user-images.githubusercontent.com/19989706/150663311-2dd36361-494d-47c8-ba92-8c9a50d5b876.gif)
> 고전적인 배치 처리의 이벤트 시간/처리 시간에 따른 모습

![stsy_0604](https://user-images.githubusercontent.com/19989706/161738011-37fa67a3-7b45-4df9-b574-05c52445e296.gif)
> 고전적인 배치 처리의 스트림/테이블 관점

이전에는 초기 변환 과정을 생략했으나 여기서는 초기 파싱 연산을 포함했다. 이를 통해 합을 내는 그룹핑 연산과 파싱이라는 비그룹핑 연산의 차이를 대조해볼 수 있다. 비그룹핑 연산은 스트림을 받아 다른 스트림을 생성한다. 반면, 그룹핑 연산은 스트림으로 들어오는 모든 데이터를 합에 포함시킴으로써 휴지 상태로 만들고 있다.

이 예가 유한 데이터에 이뤄지는 배치 처리이기에 최종 결과는 입력이 끝난 직후 생성된다. 그러나 무한 데이터 상황으로 가면 입력이 끝나지 않기 때문에 이야기가 달라진다.

##### 최종 결과를 저장하는 싱크 과정이 꼭 필요할까?
그림의 스트림/테이블 부분을 보면, 파이프라인 내에서 결과로 나온 합을 추가로 변환할 필요가 없다면, 시간에 따라 새 데이터가 도착하면서 그룹핑 연산으로 생성된 테이블에 우리가 원하는 결과가 들어가 있게 된다. 그럼 그 테이블에서 필요할 때마다 결과를 읽어오면 되지 않을까? 이런 방식은 출력을 구체화하기 위해 파이프라인에 추가적인 싱크 과정을 추가할 필요가 없다. 조심해야 할 사항은 해당 테이블을 외부에서 수정할 수 없고, 데이터 처리 파이프라인에서만 수정할 수 있도록 제한해야 한다. 값이 외부 수정으로 바뀔 수 있다면 일관성 보장은 어려워진다.
> e.g. 구글 밀휠(MillWheel) 사용자들 역시 빅테이블 기반의 상태 테이블에서 데이터를 직접 꺼내 서비스하는 식으로 동일한 접근을 썻고, 구글 플룸(Flume) 내에 파이프라인 밖에서도 상태에 접근할 수 있는 직접적인 지원을 추가하고 있다.

### 어디서: 윈도우
윈도우는 이벤트 시간의 어디에서 그룹핑이 발생할지 이야기해준다. 

윈도우가 스트림/테이블 이론과 상호작용하는 면은 다음과 같다.
- 윈도우 배정(windowing assignment): 실질적으로 레코드를 하나 혹은 그 이상의 윈도우에 배치함을 뜻한다.
- 윈도우 병합(window merging): 세션처럼 데이터 기반으로 동적으로 생성되는 윈도우를 가능하게 하는 로직이다.

윈도우 배정의 결과는 단순하다. 레코드가 개념적으로 윈도우에 배치되면 해당 윈도우의 정의는 그룹핑에 사용할 암묵적인 조합 키를 생성하기 위해 해당 레코드에 사용자가 붙이는 키와 결합된다.

### 언제: 트리거
### 어떻게: 누적

## 스트림/테이블의 일반 상대론

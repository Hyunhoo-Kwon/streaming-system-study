## 목차

# 2장. 데이터 처리의 무엇을, 어디서, 언제, 어떻게

## 배치 처리의 기본: 무엇과 어디서
### 무엇: 변환
#### 무슨 결과가 계산되는가?
무슨 결과가 계산되는가? 고전적인 배치 처리에 적용되는 변환으로 살펴보자.

2장의 나머지 부분에서 다음 예를 통해 설명할 것이다. 예에서는 사용자의 개별 점수를 합해 팀 점수를 계산한다. 주어진 점수 모두는 같은 팀에 속한 사용자에게서 온 것이다.
```
Name, Team, Score,  EventTime,  ProcTime
---------------------------------------
Julie,	TeamX, 5, T12:00:26, 12:05:19
Ed,	TeamX, 7, T12:02:26, 12:05:39
Amy,	TeamX, 3, T12:03:39, 12:06:13
Fred,	TeamX, 4, T12:04:19, 12:06:39
Julie,	TeamX, 8, T12:03:06, 12:07:06
Naomi,	TeamX, 3, T12:06:39, 12:07:19
Frank,	TeamX, 9, T12:01:26, 12:08:19
Becky,	TeamX, 8, T12:07:26, 12:08:39
Naomi,	TeamX, 1, T12:07:46, 12:09:00
```

시간에 따라 데이터가 어떻게 변화하는지 보이기 위해 9개 점수를 이벤트 시간을 X축으로, 처리 시간을 Y축으로 해 그릴 것이다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0201.png" width="50%" height="50%">

입출력 소스에서 데이터를 읽어 팀/점수 쌍으로 파싱하고, 팀별 점수를 합하는 파이프라인은 다음과 같이 생겼다.

```
// 예 2-1. 배치: 합계 파이프라인
PCollection<String> raw = IO.read(...); // 가공 전의 데이터
PCollection<KV<String, Integer>> input = raw.apply(new ParseFn());  // 팀 이름의 문자열을 키로, 개별 팀 멤버의 점수인 정수를 값으로 파싱
PCollection<KV<String, Integer>> totals = 
  input.apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

해당 파이프라인이 단일 키 데이터셋에 적용되는 모습의 그림이다. 파이프라인이 동작하는 실제 시간은 Y축(처리 시간)을 따라 아래에서 위로 진행되는 것으로 볼 수 있으며, 위로 올라가는 검은색 수평선으로 시간의 흐름을 표시할 것이다. 입력은 원으로 표시되며, 원 안의 숫자는 특정 데이터의 값을 보여준다. 입력은 옅은 회색으로 시작해 파이프라인에 의해 관찰된 후에는 짙은 색이 된다. 파이프라인이 입력 값을 관찰하면 중간 과정에서 누적하며, 마지막엔 집계된 결과를 구체화해 출력한다. 이 중간 상태나 최종 출력은 사각형으로 표시되며, 도중에는 회색, 최종에는 파란색을 쓰고, 위쪽에 누적 결과를 보여준다.

![stsy_0203](https://user-images.githubusercontent.com/19989706/150663311-2dd36361-494d-47c8-ba92-8c9a50d5b876.gif)

배치 파이프라인이기 때문에, 입력을 모두 다 볼 때까지 중간 상태를 누적하고, 그 후에 단일 결과인 48을 출력한다. 이 예에서는 윈도우 변환을 적용하고 있지 않기 때문에 이벤트 시간 전반에 대한 합을 계산한다. 무한 데이터를 처리하는 것이 목적이라면 이런 식의 배치 처리로는 충분하지 않다. 입력을 모두 볼 때까지 기다려야 하는데 입력이 영원히 끝나지 않기 때문이다. 이때 필요한 개념 중 하나가 윈도우다.

### 어디서: 윈도우
#### 이벤트 시간의 어디서 결과가 계산되는가?
윈도우는 데이터 소스를 시간 경계를 따라 자르는 작업이다.

점수 합계 파이프라인에 2분 단위 고정 윈도우를 적용해보자.
```
// 예 2-2. 배치: 윈도우 합 파이프라인 
PCollection<KV<String, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))) // 2분 단위 고정 윈도우 적용
  .apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

이전과 마찬가지로 배치 파이프라인이기 때문에, 입력을 모두 다 볼 때까지 중간 상태를 누적하고, 입력이 모두 소비된 후에 결과가 생성된다. 이 예에서는 1개의 결과 대신 2분 단위 이벤트 시간 윈도우와 연결된 4개의 결과를 얻게 된다.

![stsy_0205](https://user-images.githubusercontent.com/19989706/150684188-17fc6071-7b2f-402e-a622-e52e4f871a52.gif)

## 스트리밍으로 전환: 언제와 어떻게
우리가 원하는 이상적인 모습은 결과가 출력될 때까지 지연은 짧되 무한 데이터 입력을 다룰 수 있는 방법이다. 따라서 배처 시스탬과 같이 입력을 모두 다 본 후 결과를 얻는 전략은 쓸 수 없다.

### 언제: 트리거가 좋은 이유는 트리거가 좋기 때문이다!
#### 처리 시간의 언제 결과가 구체화되는가?
트리거는 처리 시간에서 언제 윈도우의 결과가 생성돼야 하는지를 선언해준다. 윈도우별로 생성되는 각 출력을 윈도우의 패널(pane)이라고 부른다.

트리거의 종류는 많지만 개념적으로 보통 두 종류의 트리거가 유용하며, 거의 이 둘 중 하나나 둘이 조합된 형태가 쓰인다.
- 반복 업데이트 트리거(repeated update trigger)
- 완료 트리거(completeness trigger)

![stsy_0206](https://user-images.githubusercontent.com/19989706/150684848-d1bc8fb4-de30-4015-b196-d6acd361bd26.gif)

### 언제: 워터마크

### 언제: 조기/정시/지연 트리거

### 언제: 허용된 지면 범위(가비지 컬렉션)

### 어떻게: 누적

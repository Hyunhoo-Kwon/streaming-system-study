## 목차

# 2장. 데이터 처리의 무엇을, 어디서, 언제, 어떻게

## 배치 처리의 기본: 무엇과 어디서
### 무엇: 변환
#### 무슨 결과가 계산되는가?
무슨 결과가 계산되는가? 고전적인 배치 처리에 적용되는 변환으로 살펴보자.

2장의 나머지 부분에서 다음 예를 통해 설명할 것이다. 예에서는 사용자의 개별 점수를 합해 팀 점수를 계산한다. 주어진 점수 모두는 같은 팀에 속한 사용자에게서 온 것이다.
```
Name, Team, Score,  EventTime,  ProcTime
---------------------------------------
Julie,	TeamX, 5, T12:00:26, 12:05:19
Ed,	TeamX, 7, T12:02:26, 12:05:39
Amy,	TeamX, 3, T12:03:39, 12:06:13
Fred,	TeamX, 4, T12:04:19, 12:06:39
Julie,	TeamX, 8, T12:03:06, 12:07:06
Naomi,	TeamX, 3, T12:06:39, 12:07:19
Frank,	TeamX, 9, T12:01:26, 12:08:19
Becky,	TeamX, 8, T12:07:26, 12:08:39
Naomi,	TeamX, 1, T12:07:46, 12:09:00
```

시간에 따라 데이터가 어떻게 변화하는지 보이기 위해 9개 점수를 이벤트 시간을 X축으로, 처리 시간을 Y축으로 해 그릴 것이다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0201.png" width="50%" height="50%">

##### 예 2-1. 배치: 합계 파이프라인
입출력 소스에서 데이터를 읽어 팀/점수 쌍으로 파싱하고, 팀별 점수를 합하는 파이프라인은 다음과 같이 생겼다.
```
// 예 2-1. 배치: 합계 파이프라인
PCollection<String> raw = IO.read(...); // 가공 전의 데이터
PCollection<KV<String, Integer>> input = raw.apply(new ParseFn());  // 팀 이름의 문자열을 키로, 개별 팀 멤버의 점수인 정수를 값으로 파싱
PCollection<KV<String, Integer>> totals = 
  input.apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

![stsy_0203](https://user-images.githubusercontent.com/19989706/150663311-2dd36361-494d-47c8-ba92-8c9a50d5b876.gif)

해당 파이프라인이 단일 키 데이터셋에 적용되는 모습의 그림이다. 파이프라인이 동작하는 실제 시간은 Y축(처리 시간)을 따라 아래에서 위로 진행되는 것으로 볼 수 있으며, 위로 올라가는 검은색 수평선으로 시간의 흐름을 표시할 것이다. 입력은 원으로 표시되며, 원 안의 숫자는 특정 데이터의 값을 보여준다. 입력은 옅은 회색으로 시작해 파이프라인에 의해 관찰된 후에는 짙은 색이 된다. 파이프라인이 입력 값을 관찰하면 중간 과정에서 누적하며, 마지막엔 집계된 결과를 구체화해 출력한다. 이 중간 상태나 최종 출력은 사각형으로 표시되며, 도중에는 회색, 최종에는 파란색을 쓰고, 위쪽에 누적 결과를 보여준다.

배치 파이프라인이기 때문에, 입력을 모두 다 볼 때까지 중간 상태를 누적하고, 그 후에 단일 결과인 48을 출력한다.
```
// 단일 결과 출력
[global window]: TeamX:48 END_OF_GLOBAL_WINDOW ON_TIME index=0 onTimeIndex=0 isFirst isLast
```

이 예에서는 윈도우 변환을 적용하고 있지 않기 때문에 이벤트 시간 전반에 대한 합을 계산한다. 무한 데이터를 처리하는 것이 목적이라면 이런 식의 배치 처리로는 충분하지 않다. 입력을 모두 볼 때까지 기다려야 하는데 입력이 영원히 끝나지 않기 때문이다. 이때 필요한 개념 중 하나가 윈도우다.

### 어디서: 윈도우
#### 이벤트 시간의 어디서 결과가 계산되는가?
윈도우는 데이터 소스를 시간 경계를 따라 자르는 작업이다.

##### // 예 2-2. 배치: 윈도우 합 파이프라인
점수 합계 파이프라인에 2분 단위 고정 윈도우를 적용해보자.
```
// 예 2-2. 배치: 윈도우 합 파이프라인
PCollection<KV<String, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))) // 2분 단위 고정 윈도우 적용
  .apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

![stsy_0205](https://user-images.githubusercontent.com/19989706/150684188-17fc6071-7b2f-402e-a622-e52e4f871a52.gif)

이전과 마찬가지로 배치 파이프라인이기 때문에, 입력을 모두 다 볼 때까지 중간 상태를 누적하고, 입력이 모두 소비된 후에 결과가 생성된다. 이 예에서는 1개의 결과 대신 2분 단위 이벤트 시간 윈도우와 연결된 4개의 결과를 얻게 된다.
```
// 4개의 결과 출력
[12:00:00, 12:02:00): TeamX:14 12:01:59 ON_TIME index=0 onTimeIndex=0 isFirst isLast
[12:02:00, 12:04:00): TeamX:18 12:03:59 ON_TIME index=0 onTimeIndex=0 isFirst isLast
[12:04:00, 12:06:00): TeamX:4  12:05:59 ON_TIME index=0 onTimeIndex=0 isFirst isLast
[12:06:00, 12:08:00): TeamX:12 12:07:59 ON_TIME index=0 onTimeIndex=0 isFirst isLast
```

> 입력을 모두 볼 때까지 기다려야 하는데 입력이 영원히 끝나지 않기 때문이다. >> 윈도우만 적용하면 입력을 모두 본지 알 수 있는가? 여전히 입력이 영원히 끝나지 않는건지? 그럼 언제 결과가 생기는거지?

## 스트리밍으로 전환: 언제와 어떻게
우리가 원하는 이상적인 모습은 결과가 출력될 때까지 지연은 짧되 무한 데이터 입력을 다룰 수 있는 방법이다. 따라서 배처 시스탬과 같이 입력을 모두 다 본 후 결과를 얻는 전략은 쓸 수 없다.

### 언제: 트리거가 좋은 이유는 트리거가 좋기 때문이다!
#### 처리 시간의 언제 결과가 구체화되는가?
트리거는 처리 시간에서 언제 윈도우의 결과가 생성돼야 하는지를 선언해준다. 윈도우별로 생성되는 각 출력을 윈도우의 패널(pane)이라고 부른다.

트리거의 종류는 많지만 개념적으로 보통 두 종류의 트리거가 유용하며, 실제 상황에서는 거의 이 둘 중 하나나 둘이 조합된 형태가 쓰인다.
- 반복 업데이트 트리거(repeated update trigger)
  - 이 트리거는 값이 변함에 따라 주기적으로 업데이트된 패널을 생성한다. 이 업데이트는 새로운 데이터가 들어올 때마다, 혹은 1분에 한 번처럼 일정 시간 이후에 발생할 수 있다.
- 완료 트리거(completeness trigger)
  - 이 트리거는 윈도우 내 입력이 일정 기준 완료됐다고 믿는 시점 이후에 패널을 생성한다. 입력이 완료되면 결과를 생성한다는 점에서 배치 처리와 유사하나, 입력 완료의 개념이 전체 입력 완료가 아닌 단일 윈도우 문맥으로 제한된다.

##### 예 2-3. 스트리밍: 반복 업데이트 트리거 - 매 레코드마다 반복해 이뤄지는 트리거
우선은 기본적인 반복 업데이트 트리거가 동작하는 모습을 살펴보자. 윈도우 합 파이프라인에 새로운 데이터가 도착할 때마다 동작하는 트리거를 적용해보자.
```
// 예 2-3. 스트리밍: 반복 업데이트 트리거 - 매 레코드마다 반복해 이뤄지는 트리거
PCollection<KV<String, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))  // 2분 단위 고정 윈도우 적용
                .triggering(Repeatedly(AfterCount(1)))) // 매 입력마다 동작하는 트리거 적용
  .apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

![stsy_0206](https://user-images.githubusercontent.com/19989706/150684848-d1bc8fb4-de30-4015-b196-d6acd361bd26.gif)

매 입력마다 결과가 생성되기에 윈도우 하나에 여러 출력 결과(패널)가 나온다. 이런 형태의 트리거는 결과를 테이블에 저장할 경우 테이블을 확인할 때마다 주어진 윈도우의 가장 최근 업데이트된 결과를 확인할 수 있다.
```
// 9개의 결과 출력
[12:00:00, 12:02:00): TeamX:5  12:01:59 EARLY   index=0 isFirst
[12:00:00, 12:02:00): TeamX:14 12:01:59 EARLY   index=1
[12:02:00, 12:04:00): TeamX:7  12:03:59 EARLY   index=0 isFirst
[12:02:00, 12:04:00): TeamX:10 12:03:59 EARLY   index=1
[12:02:00, 12:04:00): TeamX:18 12:03:59 EARLY   index=2
[12:04:00, 12:06:00): TeamX:4  12:05:59 EARLY   index=0 isFirst
[12:06:00, 12:08:00): TeamX:3  12:07:59 EARLY   index=0 isFirst
[12:06:00, 12:08:00): TeamX:11 12:07:59 EARLY   index=1
[12:06:00, 12:08:00): TeamX:12 12:07:59 EARLY   index=2
```

데이터 단위 트리거의 단점은 너무 자주 결과가 생성된다는 점이다. 매 입력마다 결과를 업데이트할 필요가 없을 경우 일정 처리 시간 동안 기다렸다가 업데이트해도 충분하다. 처리 시간에 지연을 두는 방법을 통해 합을 계산하는 식의 집계 과정은 정보 손실 없이 스트림의 규모를 줄일 수 있다. 트리거에 처리 시간 지연을 도입하는 방법에는 정렬 지연(aligned delay)와 비정렬 지연(unaligned delay)가 있다.

##### 예 2-4. 스트리밍: 반복 업데이트 트리거 - 정렬된 2분 단위 처리 시간마다 반복해 이뤄지는 트리거
윈도우 합 파이프라인에 정렬 지연을 갖는 트리거를 적용해보자.
```
// 예 2-4. 스트리밍: 반복 업데이트 트리거 - 정렬된 2분 단위 처리 시간마다 반복해 이뤄지는 트리거
PCollection<KV<String, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))  // 2분 단위 고정 윈도우 적용
                .triggering(Repeatedly(AlignedDelay(TWO_MINUTES)))) // 2분 단위 정렬 지연 트리거 적용
  .apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

![stsy_0207](https://user-images.githubusercontent.com/19989706/150942079-446b99c2-0165-41e9-b725-277fe1247a3e.gif)

```
// 6개의 결과 업데이트
// 출력 개수 왜 8개..?
[12:00:00, 12:02:00): TeamX:5  12:01:59 EARLY   index=0 isFirst
[12:00:00, 12:02:00): TeamX:14 12:01:59 ON_TIME index=1 onTimeIndex=0 isLast
[12:02:00, 12:04:00): TeamX:10 12:03:59 EARLY   index=0 isFirst
[12:02:00, 12:04:00): TeamX:18 12:03:59 ON_TIME index=1 onTimeIndex=0 isLast
[12:04:00, 12:06:00): TeamX:4  12:05:59 EARLY   index=0 isFirst
[12:04:00, 12:06:00): TeamX:4  12:05:59 ON_TIME index=1 onTimeIndex=0 isLast
[12:06:00, 12:08:00): TeamX:12 12:07:59 EARLY   index=0 isFirst
[12:06:00, 12:08:00): TeamX:12 12:07:59 ON_TIME index=1 onTimeIndex=0 isLast
```

이런 종류의 정렬 지연 트리거는 스파크 스트리밍같은 마이크로배치 스트리밍 시스템에서 만날 수 있는 형태다. 정렬 지연 트리거는 수정이 필요한 모든 윈도우에서 동시에 정기적으로 업데이트가 발생한다. 예측 가능성이 장점이지만, 모든 업데이트가 한 번에 일어나기 때문에 적절한 부하 처리가 필요하다. 이 문제에 대한 대안은 비정렬 지연을 쓰는 것이다.

##### 예 2-5. 스트리밍: 반복 업데이트 트리거 - 비정렬된 2분 단위 처리 시간마다 반복해 이뤄지는 트리거
윈도우 합 파이프라인에 비정렬 지연을 갖는 트리거를 적용해보자.
```
// 예 2-5. 스트리밍: 반복 업데이트 트리거 - 비정렬된 2분 단위 처리 시간마다 반복해 이뤄지는 트리거
PCollection<KV<String, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))  // 2분 단위 고정 윈도우 적용
                .triggering(Repeatedly(UnalignedDelay(TWO_MINUTES)))) // 2분 단위 비정렬 지연 트리거 적용
  .apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

![stsy_0208](https://user-images.githubusercontent.com/19989706/150946508-a1029274-5684-46ce-9d92-f39ecd41a117.gif)

비정렬 지연이 시스템 부하를 고르게 분산시킨다는 점에서 대규모 처리를 위해 더 좋은 선택이다.
```
// 5개의 결과 업데이트
// 출력 개수 왜 8개..?
[12:00:00, 12:02:00): TeamX:5  12:01:59 EARLY   index=0 isFirst
[12:00:00, 12:02:00): TeamX:14 12:01:59 ON_TIME index=1 onTimeIndex=0 isLast
[12:02:00, 12:04:00): TeamX:10 12:03:59 EARLY   index=0 isFirst
[12:02:00, 12:04:00): TeamX:18 12:03:59 ON_TIME index=1 onTimeIndex=0 isLast
[12:04:00, 12:06:00): TeamX:4  12:05:59 EARLY   index=0 isFirst
[12:04:00, 12:06:00): TeamX:4  12:05:59 ON_TIME index=1 onTimeIndex=0 isLast
[12:06:00, 12:08:00): TeamX:12 12:07:59 EARLY   index=0 isFirst
[12:06:00, 12:08:00): TeamX:12 12:07:59 ON_TIME index=1 onTimeIndex=0 isLast
```

분산 시스템에서는 다양한 이유로 이벤트가 발생한 시간과 시스템에 관찰되는 시간 사이에 편차가 발생한다. 결국 결과가 입력 데이터에 대해 정확하고 온전한 관점을 언제부터 제시하기 시작하는지 추정하기 어렵다는 뜻이다. 입력 완결성이 중요하다면 막연한 추정보다는 완결성에 대해 추론할 수 있는 방법이 필요하다. 이 부분이 워터마크의 역할이다.

### 언제: 워터마크
#### 처리 시간의 언제 결과가 구체화되는가?
워터마크는 이벤트 시간 영역에서 입력 완결성을 표현하는 시간적 개념이다.

이벤트 시간과 처리 시간 사이의 편차는 계속 변하는 함수 관계라고 설명한 바 있다. 그림의 빨간 선이 워터마크에 해당한다. 처리 시간이 흘러가면서 이벤트 시간이 어떻게 완결 처리되고 있는지 보여준다. 개념적으로 워터마크는 이벤트시간의 한 지점 P에서 처리 시간의 한 지점으로의 함수인 F(P) -> E 형태로 이해할 수 있다. 워터마크 E가 갖는 의미는 E 이전의 (P 이전 아닌가...?) 이벤트 시간을 갖는 모든 입력을 이미 시스템에서 봤다고 믿는다는 것이다.

<img src = "https://user-images.githubusercontent.com/19989706/150965684-2106c940-5a2e-4783-8fb0-781ccf404756.png" width="30%" height="30%">

- 완벽한 워터마크(perfect watermark)
  - 입력 데이터를 완벽하게 이해하고 있다면 완벽한 워터마크 구축이 가능해진다. 이 경우 모든 데이터는 정시에 도착하고 당연히 지연 데이터는 존재하지 않는다.
- 휴리스틱 워터마크(huristic watermark)
  - 현실적으로 완벽한 워터마크를 구축하기 어려우며 휴리스틱 워터마크가 대안이다. 휴리스틱 워터마크는 최대한 정확한 진행 상황을 추정하는 것이다. 따라서 휴리스틱 워터마크를 사용한다는 것은 지연 데이터가 발생할 수 있음을 뜻한다.


##### 예 2-6. 스트리밍: 완결 트리거 - 워터마크 완결성 트리거
워터마크는 입력에 대한 완결성을 결정하기 때문에, 완결성 트리거(completeness trigger)의 밑바탕이 된다. 윈도우 합 파이프라인에 워터마크를 기반으로 구축된 완결성 트리거를 적용해보자.
```
// 예 2-6. 스트리밍: 완결 트리거 - 워터마크 완결성 트리거
PCollection<KV<String, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))  // 2분 단위 고정 윈도우 적용
                .triggering(AfterWatermark())) // 워터마크 적용
  .apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

![stsy_0210](https://user-images.githubusercontent.com/19989706/150973580-39a86c38-dbc8-45ce-899e-cb9722f823f2.gif)

파이프라인에 완벽한 워터마크, 휴리스틱 워터마크를 적용한 결과이다. 두 경우 모두 워터마크가 윈도우의 끝을 통과할 때 윈도우가 구체화된다. 완벽한 워터마크는 시간이 흐르면서 파이프라인의 이벤트 시간 완결성을 제대로 잡아낸다. 반면 휴리스틱 워터마크에 사용된 알고리즘은 입력값 9를 놓치게 되어 결과의 정확성이 떨어졌다.

반복 업데이트 트리거와 워터마크 트리거의 큰 차이점은 워터마크 트리거가 입력의 완결 여부에 대해 판단할 수 있는 방법을 제공한다는 점이다. 시스템이 주어진 윈도우를 출력으로 구체화하기 전까지 우리는 시스템이 아직 입력이 완결됐다고 판단하지 않는다는 사실을 알 수 있다. 
> 데이터 손실 판단이 중요한 사례는 외부 조인(outer join)이다. 워터마크 같은 완결성 개념 없이는 언제까지 조인이 완결되기를 기다렸다가 포기하고 부분 조인을 출력할지 결정할 방법이 없다.

##### 워터마크의 단점
- 너무 느림
  - 워터마크가 미처리된 데이터를 기다리느라 정상적으로 지연되는 경우, 출력에 직접적으로 지연이 발생한다. 그림에서 늦게 도착한 9로 인해 다른 윈도우는 미리 완료됐음에도 뒤이은 모든 윈도우가 대기하게 된다.
- 너무 성급함
  - 휴리스틱 워터마크의 경우 지연 데이터가 발생할 수 있고 이는 부정확한 결과를 내게 된다.

반복 업데이트 트리거가 낮은 지연을 보이지만 완결성에 대한 지원이 결핍돼 있고, 워터마크가 완결성을 지원하지만 지연 문제가 발생할 수 있다면 그 둘의 장점을 결합해보면 어떨까?

### 언제: 조기/정시/지연 트리거
아파치 빔은 워터마크 트리거의 앞뒤로 반복 업데이트 트리거를 도입할 수 있다. 복합된 트리거에 의해 구체화되는 패널을 다음 세 종류로 나누기 때문에 이를 조기/정시/지연 트리거(early/on-time/late trigger)라고 부른다.
- 생략 가능한 조기 패널
  - 워터마크가 윈도우 끝을 지나기 전에 주기적으로 작동하는 반복 업데이트 트리거의 결과물이다. 이 트리거로 생성되는 패널은 예측 결과를 담고 있지만, 입력 데이터가 도착하면서 시간에 따라 윈도우가 변하는 모습을 관찰할 수 있게 해준다. 이는 워터마크가 너무 느려질 수 있는 단점을 보완해준다.
- 단일 정시 패널
  - 완결성/워터마크 트리거가 윈도우 끝을 통과한 후에 동작하는 결과물이다. 이 트리거가 중요한 이유는 이로 인해 시스템은 윈도우의 입력이 완료됐다고 믿을 수 있다.
- 생략 가능한 지연 패널
  - 워터마크가 윈동우 끝을 통과한 후에 주기적으로 작동하는 반복 업데이트 트리거의 결과물이다. 늦게 도착하는 데이터가 있다면 지연 패널이 발생한다. 이는 너무 성급하게 동작하는 워터마크의 단점을 보완해준다.

##### 예 2-7. 스트리밍: 조기/정시/지연 트리거
기존의 파이프라인에 조기 트리거로는 1분 단위 지연을 갖는 주기적인 처리 시간 트리거를, 지연 트리거로는 데이터 단위 트리거를 사용해보자.
// 예 2-7. 스트리밍: 조기/정시/지연 트리거
PCollection<KV<String, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))  // 2분 단위 고정 윈도우 적용
                .triggering(AfterWatermark()  // 워터마크 적용
                    .withEarlyFirings(AlignedDelay(ONE_MINUTES))  // 1분 단위 정렬 지연 트리거 적용
                    .withLateFirings(AfterCount(1))) // 매 입력마다 동작하는 트리거 적용
                  ))
                
  .apply(Sum.integersPerKey()) // 변환: 키 단위 합(총 팀 점수)을 계산하기 위해 각 키의 값을 더한다
```

![stsy_0211](https://user-images.githubusercontent.com/19989706/150976771-fd1e98b1-717f-4dd0-8806-031b52e8e539.gif)

### 언제: 허용된 지면 범위(가비지 컬렉션)

### 어떻게: 누적

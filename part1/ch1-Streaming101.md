## 목차
1. [스트리밍 101](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/ch1-Streaming101.md#1%EC%9E%A5-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D-101)
    1. [용어: 스트리밍이란?](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/ch1-Streaming101.md#%EC%9A%A9%EC%96%B4-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D%EC%9D%B4%EB%9E%80)
        1. [심하게 과장된 스트리밍의 한계](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/ch1-Streaming101.md#%EC%8B%AC%ED%95%98%EA%B2%8C-%EA%B3%BC%EC%9E%A5%EB%90%9C-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D%EC%9D%98-%ED%95%9C%EA%B3%84)
        2. [이벤트 시간 대 처리 시간](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/ch1-Streaming101.md#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8B%9C%EA%B0%84-%EB%8C%80-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EA%B0%84)
    3. [데이터 처리 패턴](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/ch1-Streaming101.md#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC-%ED%8C%A8%ED%84%B4)
        1. [유한 데이터](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/ch1-Streaming101.md#%EC%9C%A0%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0)
        2. [무한 데이터: 배치](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/ch1-Streaming101.md#%EB%AC%B4%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%B0%EC%B9%98)
        3. [무한 데이터: 스트리밍](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/ch1-Streaming101.md#%EB%AC%B4%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D)
---

# 1장. 스트리밍 101
##### 왜 스트리밍 데이터 처리가 주목받을까?
오늘날 빅데이터 분야에서는 왜 스트리밍 데이터 처리가 주목받고 있을까? 스트리밍으로 빠르게 결과를 얻을 수 있으며, 무한 데이터셋(unbounded dataset)을 다룰 수 있도록 설계되어 끝없이 입력되는 데이터를 더욱 쉽게 처리할 수 있다.

## 용어: 스트리밍이란?
##### 스트리밍
스트리밍이란 무엇일까? 스트리밍이라는 용어는 다양한 개념을 의미하는 용어로 쓰이고 있고, 결과적으로 스트리밍이 실제로 무엇인지, 또한 스트리밍으로 무엇을 할 수 있는지에 대한 오해만 커지게 됐다. 중의적 용어인 스트리밍을 포함해 몇 가지 용어를 분명하게 정의해보자.
- 스트리밍 시스템: 무한 데이터셋(unbounded dataset)을 염두에 두고 설계된 데이터 처리 엔진의 유형
    - 이 정의는 스트리밍은 물론 마이크로배치 구현도 포함한다.
        - 참고) 마이크로배치 시스템은 무한 데이터를 처리하기 위해 입력 데이터를 작은 배치로 모아 배치 처리를 반복 실행하는 스트리밍 시스템이다. 스파크 스트리밍이 전형적인 예에 해당한다.

##### 데이터셋
데이터 유형을 논의할 때도 용어를 정확히 사용할 필요가 있다. 데이터셋의 모양을 정의하는 두 가지 중요한 차원이 있다. 바로 기수(cardinality)와 구성(consititution)이며, 두 속성은 직교적(orthogonal)이다.

데이터셋의 기수는 데이터셋의 크기를 뜻하며, 기수의 가장 두드러진 측면은 지정된 데이터 집합이 유한인지 무한인지를 결정하는 것이다. 기수가 중요한 이유는 무한한 데이터셋의 무한함이라는 특성으로 인해 데이터를 처리하는데 부담이 발생하기 때문이다.
- 유한 데이터(bounded data): 크기가 유한한 데이터셋 유형
- 무한 데이터(unbounded data): 크기가 무한한 데이터셋 유형

데이터셋의 구성은 데이터의 물리적 표현을 나타내며, 결국 해당 데이터셋과 상호 작용할 수 있는 방법을 정의해준다.
- 테이블(table): 특정 시점의 데이터셋에 대한 전체적인 뷰를 의미하며, SQL 시스템은 적통적으로 테이블을 바탕으로 동작해왔다.
- 스트림(stream): 시간에 따라 변화하는 데이터셋의 요소 단위 뷰(element-by-element view). 맵리듀스 계통의 데이터 처리 시스템은 전통적으로 스트림을 바탕으로 동작해왔다.

### 심하게 과장된 스트리밍의 한계
#### 잘 설계된 스트리밍 시스템이 무엇을 할 수 있는가?
##### [람다 아키텍처](https://www.oreilly.com/library/view/stream-processing-with/9781491974285/ch01.html#fig-lambda-arch)
과거의 스트리밍 시스템은 짧은 지연 시간과 정확한 결과를 맞바꿨다. 스트리밍 처리로는 빠르게, 배치 처리로는 정확한 결과 제공이 가능해지면서 람다 아키텍처가 나타났다. 람다 아키텍처는 동일한 계산을 수행하는 배치 시스템과 스트리밍 시스템을 함께 운영하는 것이다. 스트리밍 시스템은 낮은 지연 시간으로 부정확한 결과를 제공하며, 얼마 후 배치 시스템이 최종적으로 정확한 결과를 보여주는 식이다.

![lambda-arch](https://www.oreilly.com/library/view/stream-processing-with/9781491974285/assets/spaf_0107.png)

하지만 독립된 두 버전의 파이프라인을 구축하고 유지해야 하며 최종엔 두 파이프라인에서 나온 결과를 병합해야 했기 때문에 람다 시스템을 유지하는 것은 번거로울 수밖에 없다.

##### 카파 아키텍처
[람다 아키텍처에 대한 의문](https://www.oreilly.com/radar/questioning-the-lambda-architecture/)(Questioning the Lambda Architecture)이라는 글은 이중으로 파이프라인을 구동할 필요가 없다고 주장한다. 그리고 주어진 작업을 위해 잘 설계된 단일 파이프라인을 적절히 구축해 실행하는 카파 아키텍처를 제안했다.

결론적으로 스트리밍 시스템이 성숙해 감에 따라, 람다 아키텍처는 빅데이터 역사에서 유물로 전락해갈 것이다.

#### 스트리밍 시스템이 배치 시스템을 이기기 위해서는?
##### 정확성(correctness)
태스크가 실패할 경우? 배치 잡은 처음부터 다시 시작할 수 있기 때문에 어떤 이벤트도 유실되지 않으며, 상태도 처음부터 다시 완전하게 만들 수 있다. 그러나 스트리밍 시스템에서 장애 처리는 그리 쉬운 일이 아니다. 스트리밍 시스템은 실패가 발생할 때 결과를 보장할 수 있는 여러 방식을 정의한다. 결과 보장이란 스트리밍 처리기 내부 상태(스트리밍 애플리케이션)의 일관성을 의미하며, 애플리케이션 상태 일관성 보장은 출력의 일관성 보장과 같지 않다.

##### 일관성 보장
- 최대 한 번(at-most-once)
    - 태스크가 실패할 때 가장 간단한 상태 보장 방법은 유실된 상태와 이벤트 복구를 위해 아무것도 하지 않는 것이다. 최대 한 번 보장은 각 이벤트를 최대 한 번 처리하는 것을 보장하는 낮은 수준의 보장 방법이다. 다시 말해 이벤트는 날아가고 결과의 정확성 보장을 위해 아무것도 하는 것이 없으므로 무보장(no guarantee)이라고도 한다.
- 최소 한 번(at-least-once)
    - 대부분의 애플리케이션은 이벤트 유실을 원하지 않는다. 최소 한 번 보장은 모든 이벤트를 처리하지만 그중 일부는 중복 처리할 수도 있다.
- 정확히 한 번 (exactly-once)
    - 이벤트 유실이 없다는 것뿐만 아니라 이벤트마다 정확히 한 번씩만 내부 상태를 갱신한다는 것을 의미한다. 기본적으로 정확히 한 번 보장은 마치 실패가 한 번도 없었던 것처럼 애플리케이션이 정확한 결과를 제공하리라는 것을 의미한다. 그러나 이 방식은 부가적인 성능 저하를 발생시킬 수 있다.
- 단대단 정확히 한 번 (end-to-end)
    - 지금까지 살펴본 보장 방식은 스트리밍 처리기가 관리하는 애플리케이션의 상태를 보장한다. 그러나 실제 스트리밍 애플리케이션에서는 스트리밍 처리 외에 최소 하나의 소스와 싱크를 갖고 있을 것이다. 단대단 보장은 전체 데이터 처리 파이프라인에 걸친 결과의 정확성을 의미한다. 각 컴포넌트가 각자 상태를 보장하는 방법을 완벽히 제공하더라도 전체 파이프라인의 단대단 보장을 제공하기는 쉽지 않다.

##### 시간 판단 도구(tools for reasoning about time)
시간 판단 도구는 다양한 이벤트 시간 왜곡이 발생하는 상황에서 무한 비순서 데이터(unbounded unordered data)를 처리할 때 반드시 필요하다.

### 이벤트 시간 대 처리 시간
무한 데이터 처리에 대해 이야기하려면 시간 영역에 대한 명확한 이해가 우선돼야 한다. 모든 데이터 처리 시스템에는 일반적으로 다음 두 형태의 시간 영역이 있다.
- 이벤트 시간(event time): 이벤트가 실제 발생한 시간
- 처리 시간(processing time): 이벤트가 처리 시스템에서 관측된 시간

이벤트 시간을 이용해 처리하면 데이터의 순서가 바뀌더라도 결과의 정확성을 보장할 수 있다. 따라서 시간에 따른 사용자 행동의 특성을 분석하거나 결제 관련 서비스나 이상 징후 감지 등의 경우에 이벤트 시간은 중요하다. 그러나 늦게 도착한 이벤트나 이벤트의 순서를 고려하지 않는다면 처리 시간을 사용할 수 있다.

이상적인 상황이라면, 어떤 사건이 발생한 즉시 처리될 것이기 때문에 이벤트 시간과 처리 시간은 동일해야 한다. 하지만 현실에서는 두 시간 사이의 시간 왜곡이 0이 아닐 뿐만 아니라, 다양한 요소를 반영한 매우 가변적인 함수 형태가 된다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0101.png" width="30%" height="30%">

정확성과 이벤트 시간이 중요한 경우라면, 처리 시간으로 윈도우를 나누면 안 되며, 이벤트 시간으로 윈도우를 나눠야 한다. 지금까지 살펴본 이벤트 시간 윈도우에서 중요한 점 하나를 간과했다. 언제 이벤트 시간 윈도우의 완결 시점을 결정할 수 있을까? 다시 말해 어떤 시점 전에 발생한 모든 이벤트가 도착한 것을 확신하기까지 얼마나 많은 시간을 기다려야 할까? 현실적으로 명확히 결정하는 것은 불가능하다.

## 데이터 처리 패턴
##### 일반적인 데이터 처리 패턴은?
배치와 스트리밍 두 형태의 엔진에서 유한/무한 두 처리 유형을 살펴보자 (마이크로배치 방식은 스트리밍으로 묶어서 다룬다).

### 유한 데이터
### 무한 데이터: 배치
### 무한 데이터: 스트리밍

# Reference
- 람다 아키텍처: https://www.oreilly.com/library/view/stream-processing-with/9781491974285/ch01.html#fig-lambda-arch
- 람다 아키텍처에 대한 의문: https://www.oreilly.com/radar/questioning-the-lambda-architecture/
- 일관성 보장: 아파치 플링크로 하는 스트림 데이터 처리 (파비안 휴스케, 바실리키 칼라브리)

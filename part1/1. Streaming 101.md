## 목차
1. [스트리밍 101](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/1.%20Streaming%20101.md#1%EC%9E%A5-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D-101)
    1. [용어: 스트리밍이란?](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/1.%20Streaming%20101.md#%EC%9A%A9%EC%96%B4-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D%EC%9D%B4%EB%9E%80)
        1. [심하게 과장된 스트리밍의 한계](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/1.%20Streaming%20101.md#%EC%8B%AC%ED%95%98%EA%B2%8C-%EA%B3%BC%EC%9E%A5%EB%90%9C-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D%EC%9D%98-%ED%95%9C%EA%B3%84)
        2. [이벤트 시간 대 처리 시간](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/1.%20Streaming%20101.md#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8B%9C%EA%B0%84-%EB%8C%80-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EA%B0%84)
    3. [데이터 처리 패턴](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/1.%20Streaming%20101.md#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC-%ED%8C%A8%ED%84%B4)
        1. [유한 데이터](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/1.%20Streaming%20101.md#%EC%9C%A0%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0)
        2. [무한 데이터: 배치](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/1.%20Streaming%20101.md#%EB%AC%B4%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B0%B0%EC%B9%98)
        3. [무한 데이터: 스트리밍](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/1.%20Streaming%20101.md#%EB%AC%B4%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D)
---

# 1장. 스트리밍 101
##### 왜 스트리밍 데이터 처리가 주목받을까?
오늘날 빅데이터 분야에서는 왜 스트리밍 데이터 처리가 주목받고 있을까? 스트리밍으로 빠르게 결과를 얻을 수 있으며, 무한 데이터셋(unbounded dataset)을 다룰 수 있도록 설계되어 끝없이 입력되는 데이터를 더욱 쉽게 처리할 수 있다.

## 용어: 스트리밍이란?
##### 스트리밍
스트리밍이란 무엇일까? 스트리밍이라는 용어는 다양한 개념을 의미하는 용어로 쓰이고 있고, 결과적으로 스트리밍이 실제로 무엇인지, 또한 스트리밍으로 무엇을 할 수 있는지에 대한 오해만 커지게 됐다. 중의적 용어인 스트리밍을 포함해 몇 가지 용어를 분명하게 정의해보자.
- 스트리밍 시스템: 무한 데이터셋(unbounded dataset)을 염두에 두고 설계된 데이터 처리 엔진의 유형
    - 이 정의는 스트리밍은 물론 마이크로배치 구현도 포함한다.
        - 참고) 마이크로배치 시스템은 무한 데이터를 처리하기 위해 입력 데이터를 작은 배치로 모아 배치 처리를 반복 실행하는 스트리밍 시스템이다. 스파크 스트리밍이 전형적인 예에 해당한다.

##### 데이터셋
데이터 유형을 논의할 때도 용어를 정확히 사용할 필요가 있다. 데이터셋의 모양을 정의하는 두 가지 중요한 차원이 있다. 바로 기수(cardinality)와 구성(consititution)이며, 두 속성은 직교적(orthogonal)이다.

데이터셋의 기수는 데이터셋의 크기를 뜻하며, 기수의 가장 두드러진 측면은 지정된 데이터 집합이 유한인지 무한인지를 결정하는 것이다. 기수가 중요한 이유는 무한한 데이터셋의 무한함이라는 특성으로 인해 데이터를 처리하는데 부담이 발생하기 때문이다.
- 유한 데이터(bounded data): 크기가 유한한 데이터셋 유형
- 무한 데이터(unbounded data): 크기가 무한한 데이터셋 유형

데이터셋의 구성은 데이터의 물리적 표현을 나타내며, 결국 해당 데이터셋과 상호 작용할 수 있는 방법을 정의해준다.
- 테이블(table): 특정 시점의 데이터셋에 대한 전체적인 뷰를 의미하며, SQL 시스템은 적통적으로 테이블을 바탕으로 동작해왔다.
- 스트림(stream): 시간에 따라 변화하는 데이터셋의 요소 단위 뷰(element-by-element view). 맵리듀스 계통의 데이터 처리 시스템은 전통적으로 스트림을 바탕으로 동작해왔다.

### 심하게 과장된 스트리밍의 한계
#### 잘 설계된 스트리밍 시스템이 무엇을 할 수 있는가?
##### [람다 아키텍처](https://www.oreilly.com/library/view/stream-processing-with/9781491974285/ch01.html#fig-lambda-arch)
과거의 스트리밍 시스템은 짧은 지연 시간과 정확한 결과를 맞바꿨다. 스트리밍 처리로는 빠르게, 배치 처리로는 정확한 결과 제공이 가능해지면서 람다 아키텍처가 나타났다. 람다 아키텍처는 동일한 계산을 수행하는 배치 시스템과 스트리밍 시스템을 함께 운영하는 것이다. 스트리밍 시스템은 낮은 지연 시간으로 부정확한 결과를 제공하며, 얼마 후 배치 시스템이 최종적으로 정확한 결과를 보여주는 식이다.

![lambda-arch](https://www.oreilly.com/library/view/stream-processing-with/9781491974285/assets/spaf_0107.png)

하지만 독립된 두 버전의 파이프라인을 구축하고 유지해야 하며 최종엔 두 파이프라인에서 나온 결과를 병합해야 했기 때문에 람다 시스템을 유지하는 것은 번거로울 수밖에 없다.

##### 카파 아키텍처
[람다 아키텍처에 대한 의문](https://www.oreilly.com/radar/questioning-the-lambda-architecture/)(Questioning the Lambda Architecture)이라는 글은 이중으로 파이프라인을 구동할 필요가 없다고 주장한다. 그리고 주어진 작업을 위해 잘 설계된 단일 파이프라인을 적절히 구축해 실행하는 카파 아키텍처를 제안했다.

결론적으로 스트리밍 시스템이 성숙해 감에 따라, 람다 아키텍처는 빅데이터 역사에서 유물로 전락해갈 것이다.

#### 스트리밍 시스템이 배치 시스템을 이기기 위해서는?
##### 정확성(correctness)
태스크가 실패할 경우? 배치 잡은 처음부터 다시 시작할 수 있기 때문에 어떤 이벤트도 유실되지 않으며, 상태도 처음부터 다시 완전하게 만들 수 있다. 그러나 스트리밍 시스템에서 장애 처리는 그리 쉬운 일이 아니다. 스트리밍 시스템은 실패가 발생할 때 결과를 보장할 수 있는 여러 방식을 정의한다. 결과 보장이란 스트리밍 처리기 내부 상태(스트리밍 애플리케이션)의 일관성을 의미하며, 애플리케이션 상태 일관성 보장은 출력의 일관성 보장과 같지 않다.

##### 일관성 보장
- 최대 한 번(at-most-once)
    - 태스크가 실패할 때 가장 간단한 상태 보장 방법은 유실된 상태와 이벤트 복구를 위해 아무것도 하지 않는 것이다. 최대 한 번 보장은 각 이벤트를 최대 한 번 처리하는 것을 보장하는 낮은 수준의 보장 방법이다. 다시 말해 이벤트는 날아가고 결과의 정확성 보장을 위해 아무것도 하는 것이 없으므로 무보장(no guarantee)이라고도 한다.
- 최소 한 번(at-least-once)
    - 대부분의 애플리케이션은 이벤트 유실을 원하지 않는다. 최소 한 번 보장은 모든 이벤트를 처리하지만 그중 일부는 중복 처리할 수도 있다.
- 정확히 한 번 (exactly-once)
    - 이벤트 유실이 없다는 것뿐만 아니라 이벤트마다 정확히 한 번씩만 내부 상태를 갱신한다는 것을 의미한다. 기본적으로 정확히 한 번 보장은 마치 실패가 한 번도 없었던 것처럼 애플리케이션이 정확한 결과를 제공하리라는 것을 의미한다. 그러나 이 방식은 부가적인 성능 저하를 발생시킬 수 있다.
- 단대단 정확히 한 번 (end-to-end)
    - 지금까지 살펴본 보장 방식은 스트리밍 처리기가 관리하는 애플리케이션의 상태를 보장한다. 그러나 실제 스트리밍 애플리케이션에서는 스트리밍 처리 외에 최소 하나의 소스와 싱크를 갖고 있을 것이다. 단대단 보장은 전체 데이터 처리 파이프라인에 걸친 결과의 정확성을 의미한다. 각 컴포넌트가 각자 상태를 보장하는 방법을 완벽히 제공하더라도 전체 파이프라인의 단대단 보장을 제공하기는 쉽지 않다.

##### 시간 판단 도구(tools for reasoning about time)
시간 판단 도구는 다양한 이벤트 시간 왜곡이 발생하는 상황에서 무한 비순서 데이터(unbounded unordered data)를 처리할 때 반드시 필요하다.

### 이벤트 시간 대 처리 시간
무한 데이터 처리에 대해 이야기하려면 시간 영역에 대한 명확한 이해가 우선돼야 한다. 모든 데이터 처리 시스템에는 일반적으로 다음 두 형태의 시간 영역이 있다.
- 이벤트 시간(event time): 이벤트가 실제 발생한 시간
- 처리 시간(processing time): 이벤트가 처리 시스템에서 관측된 시간

이벤트 시간을 이용해 처리하면 데이터의 순서가 바뀌더라도 결과의 정확성을 보장할 수 있다. 따라서 시간에 따른 사용자 행동의 특성을 분석하거나 결제 관련 서비스나 이상 징후 감지 등의 경우에 이벤트 시간은 중요하다. 그러나 늦게 도착한 이벤트나 이벤트의 순서를 고려하지 않는다면 처리 시간을 사용할 수 있다.
> 예) 정확도가 중요하지 않은 실시간 보고서를 주기적으로 생성해야 할 때가 있다. 이벤트가 도착하는 대로 집계해서 보여주는 실시간 모니터링 대시보드 애플리케이션이 해당한다.

이상적인 상황이라면, 어떤 사건이 발생한 즉시 처리될 것이기 때문에 이벤트 시간과 처리 시간은 동일해야 한다. 하지만 현실에서는 두 시간 사이의 시간 왜곡이 0이 아닐 뿐만 아니라, 다양한 요소를 반영한 매우 가변적인 함수 형태가 된다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0101.png" width="30%" height="30%">

무한 데이터셋의 무한함이라는 특성을 다루기 위해 인입되는 데이터를 윈도우(window)라는 단위로 잘라 다룰 수 있는 개념을 제공한다.
- 윈도우: 시간 경계를 기준으로 데이터셋을 유한한 크기의 조각으로 자르는 것

정확성과 이벤트 시간이 중요한 경우라면, 처리 시간으로 윈도우를 나누면 안 되며, 이벤트 시간으로 윈도우를 나눠야 한다. 지금까지 살펴본 이벤트 시간 윈도우에서 중요한 점 하나를 간과했다. 언제 이벤트 시간 윈도우의 완결 시점을 결정할 수 있을까? 다시 말해 어떤 시점 전에 발생한 모든 이벤트가 도착한 것을 확신하기까지 얼마나 많은 시간을 기다려야 할까? 현실적으로 명확히 결정하는 것은 불가능하다. (2장 워터마크에서 더 살펴보자)

## 데이터 처리 패턴
##### 일반적인 데이터 처리 패턴은?
배치와 스트리밍 두 형태의 엔진에서 유한/무한 두 처리 유형을 살펴보자 (마이크로배치 방식은 스트리밍으로 묶어서 다룬다).

### 유한 데이터
유한 데이터 처리는 간단한 개념이라 모든 이에게 친숙하다. 왼쪽 그림은 엔트로피(entropy)로 가득 한 시작 지점을 보여준다. 이 데이터셋을 맵리듀스 같은 데이터 처리 엔진을 통해 처리하고, 오른쪽 그림은 그 결과로 얻은 더 큰 가치를 지닌 새로운 구조화된 데이터셋을 보여준다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0102.png" width="50%" height="50%">

### 무한 데이터: 배치
배치 시스템으로 무한 데이터셋을 처리하기 위해서는 무한 데이터를 배치 처리에 적합한 유한 데이터셋의 집합으로 분할하는 것이 중요하다.

##### 고정 윈도우
배치 엔진을 반복 실행해 무한 데이터셋을 처리하는 가장 일반적인 방법은 그림처럼 입력 데이터를 고정된 크기의 윈도우(fixed window, tumbling window)로 나눈 후 각 윈도우를 분리된 유한 데이터 소스인 것처럼 처리하는 것이다. 그러나 여전히 해결해야 하는 데이터 입력이 완결됐음을 알리는 완결성(completeness)의 문제가 남아 있다. 결국 모든 이벤트 수집을 확인할 때까지 처리를 지연하거나, 데이터가 늦게 도착하면 소속될 윈도우에 대해 전체 배치를 재실행하는 등의 방법으로 이런 문제의 영향을 완화한다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0103.png" width="50%" height="50%">

##### 세션
배치 엔진을 사용해 무한 데이터를 세션(session)처럼 더 정교한 윈도우 전략으로 처리하고자 한다면 접근 방식을 더욱 상세하게 나눌 수 있다. 세션은 보통 세션의 활동 기간(activity)으로 정의되며, 일정 크기의 세션의 비활동 간격(inactivity gap)이 따라오면 끝나는 것으로 볼 수 있다. 일반적인 배치 엔진을 사용해 세션을 계산하면 그림처럼 여러 배치로 나뉘어진 세션이 나타날 수 있다. 이전 배치에 나온 세션을 묶어주기 위한 로직이 필요하지만 이는 복잡도가 증가한다. 따라서 고전적인 배치 엔진을 사용해 세션을 계산하는 것은 바람직하지 않다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0104.png" width="50%" height="50%">

### 무한 데이터: 스트리밍
스트리밍 시스템은 무한 데이터 처리를 위해 제작됐다. 스트리밍 시스템이 다루는 데이터는 다음과 같은 특성을 갖는다.
- 무한 데이터
- 정렬되지 않은 데이터 소스: 이벤트 시간 기준으로 데이터의 순서가 뒤섞여 있어 이벤트 시간을 기준으로 처리하려면 파이프라인에서 시간 기반의 셔플을 수행해야 하는 데이터
- 이벤트 시간 왜곡: 다양한 형태의 이벤트 타임 왜곡이 발생해 상수 시간 범위 안에 주어진 이벤트 시간의 대부분의 데이터를 봤다고 확신할 수 없는 데이터

이와 같은 특성의 데이터를 다룰 때 취할 수 있는 몇 가지 접근법이 있다. 우리는 보통 이를 시간 무시(time-agnostic), 근사(approximation), 처리 시간 윈도우(processing time window), 이벤트 시간 윈도우(event time window)의 네 가지로 분류한다.

##### 시간 무시(time-agnostic)
시간 무시 처리는 시간이 본질적으로 무관한 경우, 즉 데이터 처리의 모든 결정을 데이터만 보면서 할 수 있을 때 사용한다. 이 경우 모든 결정은 데이터가 도착하면서 이뤄지기 때문에, 스트리밍 엔진은 기본적인 데이터 전달 목적으로만 사용된다.

시간 무시 처리의 구체적인 예
- 필터링(filtering): 시간 무시 처리의 가장 기본적인 형태는 필터링이다. 웹 트래픽 로그를 처리하면서 특정 도메인을 제외한 모든 트래픽을 필터링한다고 가정해보자. 이런 식의 작업은 항상 데이터의 단일 요소(예에서는 도메인)에만 의존하기 때문에 무한하고 정렬되지 않은 데이터 소스의 특징과 이벤트 시간 왜곡에 무관해진다.
    - <img src = "http://streamingbook.net/static/images/figures/stsy_0105.png" width="50%" height="50%">
- 내부 조인(inner join): 시간 무시 처리의 다른 예는 내부 조인으로, 2개의 무한 데이터 소스를 조인할 때 조인의 결과만 중요하다면 시간적인 요소를 고려할 필요가 없다. 한 소스로부터 값을 확인하고 이를 조인을 위해 버퍼링 해두며, 다른 소스로부터 두 번째 값이 도착한 후 조인 결과를 생성한다.
    - <img src = "http://streamingbook.net/static/images/figures/stsy_0106.png" width="50%" height="50%">
    - 참고) 처리 방법을 내부 조인에서 외부 조인으로 전환하면 데이터의 완결성 문제가 발생한다. 조인의 한 쪽을 본 후에, 다른 쪽이 도착할지 안 할지를 예측할 수 가없다. 결국 데이터의 완결을 결정 내리기 위한 타임아웃을 도입해야 하고, 이는 곧 시간적인 개념을 포함한다는 의미가 된다. 외부 조인은 [2장](https://github.com/Hyunhoo-Kwon/streaming-system-study/blob/main/part1/2.%20The%20What%2C%20Where%2C%20When%2C%20and%20How%20of%20Data%20Processing.md#%EC%98%88-2-6-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D-%EC%99%84%EA%B2%B0-%ED%8A%B8%EB%A6%AC%EA%B1%B0---%EC%9B%8C%ED%84%B0%EB%A7%88%ED%81%AC-%EC%99%84%EA%B2%B0%EC%84%B1-%ED%8A%B8%EB%A6%AC%EA%B1%B0)에서 살펴본다.

##### 근사 알고리즘(approximation algorithm)
[Top-N](https://pkghosh.wordpress.com/2014/09/10/realtime-trending-analysis-with-approximate-algorithms/), [K-means](https://databricks.com/blog/2015/01/28/introducing-streaming-k-means-in-spark-1-2.html) 등 근사 알고리즘은 무한 데이터를 입력으로 받아 얻고자 하는 결과와 비슷한 결과를 생성한다. 근사 알고리즘의 장점은 낮은 오버헤드를 갖고 무한 데이터를 고려해 설계됐다는 것이다. 단점은 알고리즘 종류가 많지 않고 알고리즘 자체가 복잡하며 근사적인 특성으로 인해 정확한 결과가 필요할 때는 유용성이 떨어질 수 있다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0107.png" width="50%" height="50%">

#### 윈도우(window)
윈도우는 유한 또는 무한 데이터 소스를 가져와 처리를 위해 시간 경계를 따라 유한한 크기의 조각으로 자르는 개념이다. 그림은 세 가지 다른 윈도우 사용 형태를 보여준다. 모든 데이터에 같은 시점에 적용되는 정렬 윈도우(aligned window)와 데이터마다 다른 시점에 적용되는 비정렬 윈도우(unaligned window) 사이의 차이를 볼 수 있다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0108.png" width="50%" height="50%">

- 고정 윈도우(fixed window), 일명 텀블링 윈도우(tumbling window)
    - 고정 윈도우는 시간을 고정된 크기의 길이로 자른다. 일반적으로 고정 윈도우로 자르는 과정은 정렬 윈도우의 형태를 갖으며, 경우에 따라서는 윈도우 구성이 완료되는 시점을 고르게 분산시키기 위해 데이터마다 시간이 어긋나도록 윈도우를 적용하여 비정렬 윈도우 형태를 갖는다.
- 슬라이딩 윈도우(sliding window), 일명 호핑 윈도우(hopping window)
    - 슬라이딩 윈도우는 일정한 길이와 일정한 주기로 정의된다. 이때 주기가 길이보다 작으면 윈도우 간에 겹치는 부분이 발생한다. 주기가 길이와 같으면 고정 윈도우가 되며, 주기가 윈도우보다 크다면 시간에 따라 데이터의 일정 부분을 샘플링하는 윈도우가 된다.
- 세션(session)
    - 동적 윈도우(dynamic window)의 한 예로 볼 수 있는 세션은 보통 세션의 비활동 간격으로 구분해 일련의 연속된 이벤트들을 묶어서 윈도우를 구성한다. 세션은 보통 시간적으로 관련돼 있는 이벤트를 묶어서 시간에 따른 사용자의 행동을 분석하기 위해 사용한다. 세션이 흥미로운 이유는, 그 길이가 미리 정해질 수 없기 때문이다. 또한 데이터의 서로 다른 부분에 동일한 윈도우를 적용할 수 없기 때문에 비정렬 윈도우의 형태를 갖는다.

윈도우는 처리 시간과 이벤트 시간 영역에서 모두 사용 가능하므로, 각각을 자세히 살펴보며 차이를 확인하자.

##### 처리 시간 윈도우(processing time window)
처리 시간 윈도우를 구성할 때 시스템은 어느 정도의 처리 시간이 지날 때까지 들어오는 데이터를 버퍼링한다. 처리 시간 윈도우는 파이프라인에 도착하는 순서에 따라 데이터가 윈도우로 수집된다.
> 예를 들어 5분 길이의 고정 윈도우의 경우, 시스템은 5분 동안의 입력 데이터를 버퍼링하며, 그 후 5분 동안 관찰된 모든 데이터를 윈도우로 묶어 다음 처리를 위해 보낸다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0109.png" width="50%" height="50%">

처리 시간 윈도우에는 다음 특성이 있다.
- 시간을 기준으로 데이터를 셔플링할 필요가 없기 때문에 구현이 간단하다.
- 윈도우가 완료되는 시점을 판단하기가 쉽다. 언제 특정 윈도우의 입력이 모두 도착하는지 알기 때문에 윈도우의 완료 시점이 명확하다. 이는 지연된 데이터를 다룰 필요가 없음을 의미한다.
- 데이터 소스가 관측되는 시점을 기준으로 정보를 추론하고자 하는 경우, 처리 시간 윈도우가 적합하다.
    - > 운영 중단을 감지하기 위한 목적으로 초당 요청 개수를 모니터링하는 경우라면 처리 시간 윈도우가 필요한 경우이다.

처리 시간 윈도우가 실제 이벤트가 발생한 순서를 제대로 반영해야 한다면, 데이터가 이벤트 시간 순서대로 들어와야 한다. 그러나 현실에서 이벤트 시간 순서가 보장돼 들어오는 데이터는 드물다. 이벤트 도착 순서를 엄격히 따라 이벤트 시간별로 데이터를 표시하기 위해서는 이벤트 시간 윈도우가 필요하다.

##### 이벤트 시간 윈도우(event time window)
이벤트 시간 윈도우는 이벤트가 실제 발생한 시간을 반영해 유한한 크기의 조각으로 데이터 소스를 관찰하고자 할 때 사용한다. 그림은 무한 데이터 소스를 한 시간 단위의 고정 윈도우로 처리하는 예를 보여준다. 검은색 화살표는 원래 속해야 하는 이벤트 시간 윈도우와 다른 처리 시간 윈도우에 도착한 데이터를 나타낸다. 이벤트 시간에 대한 정확성 제공은 이벤트 시간 윈도우를 사용할 때 좋은 점 중 하나다. 

<img src = "http://streamingbook.net/static/images/figures/stsy_0110.png" width="50%" height="50%">

무한 데이터 소스에 이벤트 시간 윈도우를 적용할 때의 또 다른 장점은, 세션 같은 동적인 크기의 윈도우를 만들 수 있어, 고정 윈도우에 걸쳐 있는 세션을 임의로 분할해야 하는 상황을 피할 수 있다.

<img src = "http://streamingbook.net/static/images/figures/stsy_0111.png" width="50%" height="50%">

이벤트 시간 윈도우는 실제 윈도우 자체의 길이보다 이를 수집해 구성하는 시간이 길어지는 경우가 많기 때문에 다음과 같은 단점을 갖는다.
- 버퍼링(buffering)
    - 윈도우의 수명이 길어짐에 따라 더 많은 데이터를 버퍼링할 필요가 생긴다.
- 완결성(completeness)
    - 주어진 윈도우에 대한 모든 데이터를 언제 다 볼 수 있는지(입력이 완료되었는지) 미리 알 수 없다면 윈도우의 결과가 언제 구체화될지 어떻게 알 수 있을까? 현실적으로 완벽히 알 방법이 없으며 휴리스틱으로 최대한 정확히 추정해야 하며, 워터마크를 사용해 데이터 입력의 완결 여부를 판단한다.

# Reference
- 람다 아키텍처: https://www.oreilly.com/library/view/stream-processing-with/9781491974285/ch01.html#fig-lambda-arch
- 람다 아키텍처에 대한 의문: https://www.oreilly.com/radar/questioning-the-lambda-architecture/
- 일관성 보장: 아파치 플링크로 하는 스트림 데이터 처리 (파비안 휴스케, 바실리키 칼라브리)
